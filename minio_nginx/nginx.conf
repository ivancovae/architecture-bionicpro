# Nginx конфигурация для reverse proxy перед MinIO с JWT-валидацией
# Использует OpenResty (nginx + Lua) для проверки JWT-токенов

# Рабочие процессы
worker_processes auto;

# События
events {
    worker_connections 1024;
}

http {
    # Базовые настройки
    include /usr/local/openresty/nginx/conf/mime.types;
    default_type application/octet-stream;
    
    # Логирование
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log info;
    
    # Оптимизация для больших файлов
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    
    # Отключаем буферизацию для проксирования больших файлов
    # Это позволяет стримить файлы без загрузки в память
    proxy_buffering off;
    proxy_request_buffering off;
    
    # Таймауты
    keepalive_timeout 65;
    proxy_connect_timeout 60s;
    proxy_send_timeout 60s;
    proxy_read_timeout 60s;
    
    # Максимальный размер тела запроса (для PUT-запросов, хотя мы их блокируем)
    client_max_body_size 100M;
    
    # Lua-модули для работы с JWT
    lua_package_path "/usr/local/openresty/lualib/?.lua;;";
    lua_shared_dict jwks 1m;  # Кэш для JWKS (JSON Web Key Set)
    
    # Upstream для MinIO
    upstream minio_backend {
        server minio:9000;  # Имя сервиса MinIO в Docker Compose
    }
    
    server {
        listen 9001;  # Порт для доступа к nginx reverse proxy
        server_name localhost;
        
        # Обработка запросов к /reports/*
        location ~ ^/reports/(.*)$ {
            # Логируем запрос
            access_log /var/log/nginx/minio_access.log;
            
            # Разрешаем только GET-запросы
            if ($request_method !~ ^(GET|HEAD)$) {
                return 405;  # Method Not Allowed
            }
            
            # Валидация JWT и проверка прав доступа через Lua
            access_by_lua_block {
                -- Получаем JWT из заголовка Authorization
                local auth_header = ngx.var.http_authorization
                
                if not auth_header then
                    ngx.log(ngx.ERR, "Missing Authorization header")
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Missing Authorization header"}')
                    return ngx.exit(401)
                end
                
                -- Извлекаем токен из заголовка "Bearer <token>"
                local token = auth_header:match("^Bearer%s+(.+)$")
                if not token then
                    ngx.log(ngx.ERR, "Invalid Authorization header format")
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Invalid Authorization header format"}')
                    return ngx.exit(401)
                end
                
                -- Декодируем JWT (без проверки подписи, так как это делает auth_proxy)
                -- В production-среде нужно проверять подпись через JWKS от Keycloak
                local cjson = require "cjson"
                local base64 = require "ngx.base64"
                
                -- JWT состоит из трёх частей, разделённых точками: header.payload.signature
                local parts = {}
                for part in token:gmatch("[^%.]+") do
                    table.insert(parts, part)
                end
                
                if #parts ~= 3 then
                    ngx.log(ngx.ERR, "Invalid JWT format")
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Invalid JWT format"}')
                    return ngx.exit(401)
                end
                
                -- Декодируем payload (вторая часть)
                local payload_encoded = parts[2]
                
                -- Добавляем padding, если необходимо (base64url требует кратности 4)
                local padding = (4 - #payload_encoded % 4) % 4
                payload_encoded = payload_encoded .. string.rep("=", padding)
                
                -- Заменяем base64url символы на base64
                payload_encoded = payload_encoded:gsub("-", "+"):gsub("_", "/")
                
                -- Декодируем base64
                local payload_json = base64.decode_base64url(payload_encoded)
                if not payload_json then
                    ngx.log(ngx.ERR, "Failed to decode JWT payload")
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Failed to decode JWT payload"}')
                    return ngx.exit(401)
                end
                
                -- Парсим JSON
                local ok, payload = pcall(cjson.decode, payload_json)
                if not ok then
                    ngx.log(ngx.ERR, "Failed to parse JWT payload: ", payload)
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Failed to parse JWT payload"}')
                    return ngx.exit(401)
                end
                
                -- Проверяем срок действия токена
                local exp = payload.exp
                if exp and exp < ngx.time() then
                    ngx.log(ngx.ERR, "JWT token expired")
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "JWT token expired"}')
                    return ngx.exit(401)
                end
                
                -- Получаем роли пользователя
                local roles = payload.realm_roles or {}
                if not roles or type(roles) ~= "table" then
                    -- Пробуем старый формат realm_access.roles
                    local realm_access = payload.realm_access
                    if realm_access and type(realm_access) == "table" then
                        roles = realm_access.roles or {}
                    else
                        roles = {}
                    end
                end
                
                -- Получаем UUID пользователя (external_uuid или sub)
                -- Приоритет у external_uuid, так как reports_api использует его для путей к файлам в приоритете
                local user_uuid = payload.external_uuid or payload.sub
                if not user_uuid then
                    ngx.log(ngx.ERR, "JWT token does not contain user UUID")
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "JWT token does not contain user UUID"}')
                    return ngx.exit(401)
                end
                
                -- Проверяем, является ли пользователь администратором
                local is_admin = false
                for _, role in ipairs(roles) do
                    if role == "administrators" then
                        is_admin = true
                        break
                    end
                end
                
                -- Извлекаем путь к файлу из URI
                -- URI имеет формат: /reports/{schema}/{user_uuid}/{filename}
                local uri = ngx.var.uri
                local path_parts = {}
                for part in uri:gmatch("[^/]+") do
                    table.insert(path_parts, part)
                end
                
                -- path_parts[1] = "reports"
                -- path_parts[2] = schema (например, "default" или "debezium")
                -- path_parts[3] = user_uuid из пути
                -- path_parts[4] = filename
                
                if #path_parts < 3 then
                    ngx.log(ngx.ERR, "Invalid path format: ", uri)
                    ngx.status = 400
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Invalid path format"}')
                    return ngx.exit(400)
                end
                
                local file_user_uuid = path_parts[3]
                
                -- Проверяем права доступа
                if is_admin then
                    -- Администратор имеет доступ к любым файлам
                    ngx.log(ngx.INFO, "Admin access granted for user: ", user_uuid, " to file: ", uri)
                else
                    -- Обычный пользователь может скачивать только свои файлы
                    if file_user_uuid ~= user_uuid then
                        ngx.log(ngx.ERR, "Access denied: user ", user_uuid, " tried to access file for user ", file_user_uuid)
                        ngx.status = 403
                        ngx.header.content_type = "application/json"
                        ngx.say('{"error": "Access denied: you can only access your own reports"}')
                        return ngx.exit(403)
                    end
                    ngx.log(ngx.INFO, "User access granted for user: ", user_uuid, " to file: ", uri)
                end
            }
            
            # Проксируем запрос к MinIO
            proxy_pass http://minio_backend$uri$is_args$args;
            
            # Заголовки для проксирования
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Заголовки для работы с MinIO
            proxy_set_header Connection "";
            proxy_http_version 1.1;
            
            # Отключаем буферизацию для стриминга больших файлов
            proxy_buffering off;
            proxy_request_buffering off;
        }
        
        # Блокируем доступ к другим путям
        location / {
            return 404;
        }
    }
}
