# Задание 3. Снижение нагрузки на базу данных

Здесь мы добавили в нашу систему два новых микросервиса: [`minio`](../minio) и [`minio-nginx`](../minio_nginx). А также немного доработали наш фронтэнд и [`reports_api`](../reports_api).

## Структура хранения отчётов

* Мы создаём публичный бакет `reports` с 2 директориями для отчётов из разных схем: `debezium` и `default`.  
* Внутри каждой директории будут поддиректории по `user_uuid` или `external_uuid`, внутрь которых и будем класть отчёты (имя файла – по началу и концу отчётного периода).  
* Время начала отчётного периода сейчас всегда выбирается "от начала времён", время конца – до 00:00 первого числа текущего месяца. Потом можно изменить эту дискретность на меньшую (например, по неделям).

### Пример структуры бакета reports:
```
reports/
├── debezium/
│   ├── 13737288-edf4-4b14-82ad-8590a4d7c306/
│   │   ├── none__2026-02-01T00-00-00.json
│   │   └── ...
│   └── ...
└── default/
    ├── 4f1228fa-89ff-49eb-a27b-876ff84359a2/
    │   ├── none__2026-02-01T00-00-00.json
    │   └── ...
    ├── .../
    │   └── ...
    └── ...
```

- `default/` и `debezium/` — схемы ClickHouse, из которых генерируются отчёты
- `{user_uuid}/` — поддиректория для каждого пользователя
- `none__2026-02-01T00-00-00.json` — файл отчёта за период от начала времён до 2026-02-01 00:00:00
- Формат имени файла: `{start_ts}__{end_ts}.json` (если start_ts не указан, используется `none`)

## minio

* [`minio`](../minio) сделаем публичным, чтобы он раздавал публичные ссылки вида `http://minio:9000/reports/default/path_to_my_reports.json`, ограничивать доступ будем через nginx-прокси;
* Веб-интерфейс для отладки будет по [http://localhost:9001](http://localhost:9001), юзер `minio_user`, пароль `minio_password`;
* подробные настройки [`minio`](../minio) – см. секцию `minio` в [`docker-compose.yaml`](../docker-compose.yaml) и папку [`minio`](../minio);
* на боевой системе [`minio`](../minio) будет доступно только изнутри кластера и через [`minio-nginx`](../minio_nginx), и в [`auth_proxy`](../auth_proxy) будет дополнительное правило, что в его методе `/proxy` нельзя проксировать обращения к [`minio`](../minio) напрямую (сейчас этого не реализовывалось).

## nginx-прокси minio-nginx

Здесь мы с Claude Sonnet создали специфическое reverse proxy с помощью OpenResty Nginx (т.е. nginx с поддержкой Lua).

Здесь [`minio-nginx`](../minio_nginx) делает следующее (с помощью Lua-скрипта):
- разбирает JWT, которое выставил [`auth_proxy`](../auth_proxy);
- проверяет роли пользователя, его `user_uuid` или `external_uuid`, сличает их с тем путём в [`minio`](../minio), куда юзер хотел обратиться;
- если UUID юзера и его права соответствуют тому пути, куда надо обратиться – проксирует запрос на [`minio`](../minio) (делает запрос на `http://minio/reports/{schema}/{user_uuid}/{report_name}.json`).

Если нет прав – возвращаем 403 Error.
Если файл не найден – 404 Error.

## Доработки в Reports API

В эндпоинте `/reports` мы теперь подключаемся к [`minio`](../minio) через python-клиент `minio` – и кладём JSONку с отчётом в соответствующую директорию [`minio`](../minio).

## Доработки на фронтэнде

Теперь [`bionicpro_frontend`](../bionicpro_frontend) сначала обращается в метод `/proxy` сервиса [`auth_proxy`](../auth_proxy) с другим путём проксирования (т.е. с обращением к [`minio-nginx`](../minio_nginx)):
```json
{
  "method": "GET",
  "redirect_to_sign_in": false,
  "upstream_uri": "http://minio-nginx:9001/reports/debezium/13737288-edf4-4b14-82ad-8590a4d7c306/none__2026-02-01T00-00-00.json"
}
```

Если это вернуло 404 Error, то потом будет обычное обращение к [`auth_proxy`](../auth_proxy) с путём проксирования в `/reports`:
```json
{
  "upstream_uri": "http://reports-api:3003/reports",
  "method": "POST",
  "redirect_to_sign_in": false,
  "body": {
    "start_ts": null,
    "end_ts": "2026-02-01T00:00:00.000Z",
    "schema": "debezium"
  }
}
```

## Как проверить

Заходим в [http://localhost:3000](http://localhost:3000) под каким-нибудь пользователем, под которым ещё не смотрели отчёты (например, юзер `customer1` с паролем `customer1_password`).

Открываем Chrome → Инструменты разработчика → Network

Жмём кнопку: “Отчёт (default)”.

На первый раз отчёт выведется с признаком "Не из кэша" и будут 2 запроса к [**`auth_proxy`**](../auth_proxy): неуспешный (проксирование запроса к [**`minio-nginx`**](../minio_nginx)) и успешный (проксирование запроса к [**`reports_api`**](../reports_api) -> `/reports`).
![minio_2.png](minio_2.png)
_Неуспешный запрос к кэшу_

![minio_3.png](minio_3.png)
_И запрос в [**`reports_api`**](../reports_api), отсюда получаются 2 обращения к `/proxy`_

Жмём кнопку “Отчёт (default)” ещё раз.
На этот раз отчёт выведется с признаком "Из кэша" и будет 1 запрос к [**`auth_proxy`**](../auth_proxy) (успешный, проксирование запроса к [**`minio-nginx`**](../minio_nginx)).

![minio_1.png](minio_1.png)
_Теперь запрос из кэша будет успешным, и отсюда только 1 обращение к `/proxy`_

## Обновление кэша

### TTL для файлов отчётов

Настроен lifecycle policy на уровне бакета MinIO с автоматическим удалением файлов через **7 дней**:

- **[`minio`](../minio)**: При инициализации контейнера настраивается lifecycle policy для бакета `reports`
  - Файлы старше 7 дней автоматически удаляются MinIO
  - Правило `ExpireOldReports` применяется ко всем файлам в бакете
  - Реализация: [`minio/init-minio.sh`](../minio/init-minio.sh)

- **[`reports_api`](../reports_api)**: Просто сохраняет отчёты в MinIO без установки TTL

Таким образом:
- Отчёты автоматически удаляются через **7 дней** после создания
- Управление TTL централизовано в конфигурации MinIO